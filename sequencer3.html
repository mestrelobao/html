<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Online Sequencer Pro (Real Drums)</title>

<style>
  body {
    font-family: Arial, sans-serif;
    background: #121212;
    color: white;
    text-align: center;
    padding-bottom: 200px;
  }

  #controls {
    margin-top: 20px;
  }

  #tempoControl {
    margin-top: 10px;
  }

  #gridContainer {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 25px;
  }

  #volumes {
    display: grid;
    grid-template-rows: repeat(8, 32px);
    grid-gap: 5px;
    margin-top: 5px;
  }

  .volRow {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 140px;
  }

  #grid {
    display: grid;
    grid-template-columns: repeat(16, 32px);
    grid-gap: 4px;
  }

  .cell {
    width: 32px;
    height: 32px;
    background: #2c2c2c;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.1s, box-shadow 0.1s;
  }

  .cell.active {
    filter: brightness(1.25);
  }

  .cell.current {
    box-shadow: 0 0 12px #ff4ebd, 0 0 5px #ff006a inset;
  }

  button {
    padding: 10px 25px;
    font-size: 17px;
    margin: 10px;
    border: none;
    background: #00aaff;
    color: white;
    border-radius: 8px;
    cursor: pointer;
  }

  button:hover {
    filter: brightness(1.15);
  }
</style>
</head>

<body>

<h1>Online Sequencer Pro</h1>
<p>808 Real Drum Kit + Synth Instruments</p>

<div id="controls">
  <button id="play">Play</button>
  <button id="save">Save</button>
  <button id="load">Load</button>
  <button id="export">Export WAV</button>

  <div id="tempoControl">
    <label for="tempo">Tempo: <span id="tempoValue">120</span> BPM</label><br>
    <input type="range" id="tempo" min="40" max="240" value="120">
  </div>
</div>

<div id="gridContainer">
  <div id="volumes"></div>
  <div id="grid"></div>
</div>

<script>
/* -------------------------------------------------------
   SETTINGS
------------------------------------------------------- */
const rows = 8;
const cols = 16;
let tempo = 120;
const noteLength = 0.25;

/* Row colors */
const rowColors = [
  "#ff7675", "#74b9ff", "#55efc4", "#ffeaa7",
  "#a29bfe", "#fab1a0", "#81ecec", "#fd79a8"
];

/* Frequencies (used for bass & lead rows) */
const freqs = [
  60,62,65,67,69,72,74,76
].map(n => 440 * Math.pow(2, (n - 69) / 12));

/* -------------------------------------------------------
   AUDIO SETUP
------------------------------------------------------- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const masterGain = audioCtx.createGain();
masterGain.gain.value = 1;
masterGain.connect(audioCtx.destination);

const rowGains = [...Array(rows)].map(() => {
  const g = audioCtx.createGain();
  g.gain.value = 1;
  g.connect(masterGain);
  return g;
});

/* -------------------------------------------------------
   808 DRUM SAMPLE LOADER
------------------------------------------------------- */
const sampleURLs = {
  kick:  "kick.mp3",
  snare: "https://raw.githubusercontent.com/joshwcomeau/web-audio-samples/main/808/snare.wav",
  hihat: "https://raw.githubusercontent.com/joshwcomeau/web-audio-samples/main/808/hihat.wav",
  clap:  "https://raw.githubusercontent.com/joshwcomeau/web-audio-samples/main/808/clap.wav"
};

let drumBuffers = {};

async function loadSamples() {
  for (const name in sampleURLs) {
    const res = await fetch(sampleURLs[name]);
    const arr = await res.arrayBuffer();
    drumBuffers[name] = await audioCtx.decodeAudioData(arr);
  }
  console.log("Drum samples loaded âœ”");
}
loadSamples();

/* -------------------------------------------------------
   INSTRUMENT PLAYERS
------------------------------------------------------- */

function playSample(name, time, row) {
  if (!drumBuffers[name]) return;
  const src = audioCtx.createBufferSource();
  src.buffer = drumBuffers[name];
  src.connect(rowGains[row]);
  src.start(time);
}

function playKick(time, row)  { playSample("kick",  time, row); }
function playSnare(time, row) { playSample("snare", time, row); }
function playHihat(time, row) { playSample("hihat", time, row); }
function playClap(time, row)  { playSample("clap",  time, row); }

function playBass(freq, time, row) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = "sawtooth";
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(0.4, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.35);
  osc.connect(gain).connect(rowGains[row]);
  osc.start(time);
  osc.stop(time + 0.35);
}

function playLead(freq, time, row) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = "square";
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(0.25, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
  osc.connect(gain).connect(rowGains[row]);
  osc.start(time);
  osc.stop(time + 0.4);
}

/* Instrument per row */
const instruments = [
  playKick,
  playSnare,
  playHihat,
  playClap,
  playBass,
  playBass,
  playLead,
  playLead
];

/* -------------------------------------------------------
   GRID CREATION
------------------------------------------------------- */
const grid = document.getElementById("grid");
let cells = [];

for (let r = 0; r < rows; r++) {
  cells[r] = [];
  for (let c = 0; c < cols; c++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.onclick = () => {
      cell.classList.toggle("active");
      cell.style.background = cell.classList.contains("active")
        ? rowColors[r]
        : "#2c2c2c";
    };
    grid.appendChild(cell);
    cells[r][c] = cell;
  }
}

/* -------------------------------------------------------
   VOLUME SLIDERS
------------------------------------------------------- */
const volumes = document.getElementById("volumes");

for (let r = 0; r < rows; r++) {
  const div = document.createElement("div");
  div.className = "volRow";
  div.innerHTML = `
    <span>Row ${r + 1}</span>
    <input type="range" min="0" max="100" value="100" data-row="${r}">
  `;
  volumes.appendChild(div);
}

volumes.oninput = e => {
  if (!e.target.dataset.row) return;
  rowGains[e.target.dataset.row].gain.value = e.target.value / 100;
};

/* -------------------------------------------------------
   PLAYBACK SCHEDULER
------------------------------------------------------- */
let isPlaying = false;
let currentStep = 0;
let nextNoteTime = 0;
const scheduleAheadTime = 0.1;

function scheduleStep(step, time) {
  for (let r = 0; r < rows; r++) {
    if (cells[r][step].classList.contains("active")) {
      const fn = instruments[r];
      const f = freqs[r];
      if (fn === playBass || fn === playLead) fn(f, time, r);
      else fn(time, r);
    }
  }
}

function nextStep() {
  nextNoteTime += (60 / tempo) * noteLength;
  currentStep = (currentStep + 1) % cols;
}

function highlightStep(step) {
  document.querySelectorAll(".current").forEach(c => c.classList.remove("current"));
  for (let r = 0; r < rows; r++) cells[r][step].classList.add("current");
}

function scheduler() {
  if (!isPlaying) return;
  while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
    scheduleStep(currentStep, nextNoteTime);
    highlightStep(currentStep);
    nextStep();
  }
  requestAnimationFrame(scheduler);
}

/* -------------------------------------------------------
   TEMPO SLIDER
------------------------------------------------------- */
const tempoSlider = document.getElementById("tempo");
const tempoValue = document.getElementById("tempoValue");

tempoSlider.oninput = () => {
  tempo = Number(tempoSlider.value);
  tempoValue.textContent = tempo;
};

/* -------------------------------------------------------
   PLAY / STOP
------------------------------------------------------- */
document.getElementById("play").onclick = async () => {
  if (audioCtx.state === "suspended") await audioCtx.resume();

  if (!isPlaying) {
    isPlaying = true;
    this.innerText = "Stop";
    currentStep = 0;
    nextNoteTime = audioCtx.currentTime + 0.05;
    scheduler();
  } else {
    isPlaying = false;
    this.innerText = "Play";
    document.querySelectorAll(".current")
      .forEach(c => c.classList.remove("current"));
  }
};

/* -------------------------------------------------------
   SAVE / LOAD
------------------------------------------------------- */
document.getElementById("save").onclick = () => {
  const pattern = {
    tempo,
    volumes: rowGains.map(g => g.gain.value),
    grid: cells.map(row => row.map(c => c.classList.contains("active")))
  };
  localStorage.setItem("seqPattern", JSON.stringify(pattern));
  alert("Saved!");
};

document.getElementById("load").onclick = () => {
  const data = JSON.parse(localStorage.getItem("seqPattern"));
  if (!data) return alert("No pattern saved!");

  tempo = data.tempo;
  tempoSlider.value = tempo;
  tempoValue.textContent = tempo;

  data.volumes.forEach((v, r) => {
    rowGains[r].gain.value = v;
    volumes.querySelectorAll("input")[r].value = v * 100;
  });

  data.grid.forEach((row, r) =>
    row.forEach((active, c) => {
      const cell = cells[r][c];
      cell.classList.toggle("active", active);
      cell.style.background = active ? rowColors[r] : "#2c2c2c";
    })
  );

  alert("Loaded!");
};

/* -------------------------------------------------------
   EXPORT WAV (simple synth drums)
------------------------------------------------------- */
document.getElementById("export").onclick = async () => {
  const duration = cols * noteLength * (60 / tempo);
  const offline = new OfflineAudioContext(
    2,
    audioCtx.sampleRate * duration,
    audioCtx.sampleRate
  );

  const offMaster = offline.createGain();
  offMaster.connect(offline.destination);

  const offGains = rowGains.map(g => {
    const ng = offline.createGain();
    ng.gain.value = g.gain.value;
    ng.connect(offMaster);
    return ng;
  });

  // Simple tone fallback for offline export
  function playOffline(r, t, freq) {
    const osc = offline.createOscillator();
    const gain = offline.createGain();
    osc.frequency.value = freq || 200;
    gain.gain.setValueAtTime(0.5, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    osc.connect(gain).connect(offGains[r]);
    osc.start(t);
    osc.stop(t + 0.15);
  }

  let t = 0;
  const beat = 60 / tempo;

  for (let step = 0; step < cols; step++) {
    for (let r = 0; r < rows; r++) {
      if (cells[r][step].classList.contains("active"))
        playOffline(r, t, freqs[r]);
    }
    t += beat * noteLength;
  }

  const rendered = await offline.startRendering();

  function toWav(buffer) {
    const n = buffer.length;
    const ch = buffer.numberOfChannels;
    const sr = buffer.sampleRate;

    const samples = new Float32Array(n * ch);
    for (let c = 0; c < ch; c++)
      samples.set(buffer.getChannelData(c), c * n);

    const block = new ArrayBuffer(44 + samples.length * 2);
    const view = new DataView(block);

    const write = (o, s) => [...s].forEach((c,i) => view.setUint8(o+i, c.charCodeAt(0)));

    write(0, "RIFF");
    view.setUint32(4, 36 + samples.length * 2, true);
    write(8, "WAVE");
    write(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, ch, true);
    view.setUint32(24, sr, true);
    view.setUint32(28, sr * ch * 2, true);
    view.setUint16(32, ch * 2, true);
    view.setUint16(34, 16, true);
    write(36, "data");
    view.setUint32(40, samples.length * 2, true);

    let offset = 44;
    for (let i = 0; i < samples.length; i++, offset += 2)
      view.setInt16(offset, samples[i] * 0x7fff, true);

    return new Blob([block], { type: "audio/wav" });
  }

  const wav = toWav(rendered);
  const a = document.createElement("a");
  a.href = URL.createObjectURL(wav);
  a.download = "sequence.wav";
  a.click();
};
</script>

</body>
</html>
